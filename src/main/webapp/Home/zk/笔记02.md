**zookeeper** 
    
    上一笔记的复盘：
        stat
            czxid 表示该节点创建时候的事务id
            mzxid 表示该节点最后一次被更新的事务id
            ctime 表示被创建的时间
            mtime 表示最后一次修改的时间
            version 数据节点的版本号，
            cversion 子节点的版本号
            aversion 节点的acl版本号
            ephemeralOwer 创建该临时节点的会话的sessionID 如果该节点是持久节点 那么这个节点的值为 0
            datalength 数据内容的长度   zk一般存储的数据内容最好不要超过2M
            numChildren 当前节点的子节点的个数
            pzxid 表示该节点的子节点列表中的最后一个被修改时的事务id 注意，只有子节点列表变更了才会变更pzxid 子节点的内容变更不会影响pzxid
            
        版本-保证分布式数据原子性：
                 zookeeper 为数据节点引入了版本的概念，每个数据节点都有三类版本信息，对数据节点任何更新操作都会引起版本号的变化
            版本有点和我们经常使用的乐观锁类似
                悲观锁：
                    是数据库中一种非常典型且非常严格的并发控制策略。假如一个事务 A 正在对数据进行处理，那么在整个处理
                过程中，都会将数据处于锁定状态，在这期间其他事务无法对数据进行更新操作。
                乐观锁：
                    乐观锁和悲观锁正好相反，它假定多个事务在处理过程中不会彼此影响，因此在事务处理过程中不需要进行加
                锁处理，如果多个事务对同一数据做更改，那么在更新请求提交之前，每个事务都会首先检查当前事务读取数据后，是
                否有其他事务对数据进行了修改。如果有修改，则回滚事务再回到 zookeeper，version 属性就是用来实现乐观锁机制的“写入校验”
            
    zk基于java的访问：
        CuratorFramework  curatorFramework=CuratorFrameworkFactory.builder().connectString(CONNECTION_STR).sessionTimeoutMs(5000) .
                retryPolicy(new  ExponentialBackoffRetry(1000,3)).namespace(“curator ”).build(); 
        Curator 内部实现的几种重试策略: 
            ExponentialBackoffRetry:重试指定的次数, 且每一次重试之间停顿的时间逐渐增加.
            RetryNTimes:指定最大重试次数的重试策略
            RetryOneTime:仅重试一次
            RetryUntilElapsed:一直重试直到达到规定的时间      
        namespace: 值得注意的是 session2 会话含有隔离命名空间，即客户端对 Zookeeper 上数据节点的任何操作都是相对/curator目录进行的，
                这有利于实现不同的 Zookeeper 的业务之间的隔离    
            
        节点的增删改查：zookeeper.CuratorDemo
        节点的权限设置：zookeeper.AclDemo
        节点时间监听:   zookeeper.WatcherDemo     
                
        