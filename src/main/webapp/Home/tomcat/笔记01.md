tomcat优化思路：
    配置文件优化：
        减少、增加配置：
            定位到比较重要的文件,conf/web.xml  conf/server.xml   项目中的web.xml(尽可能的清理不必要的配置！)
            conf/web.xml    defaultServlet  静态资源  删除？
                            jspServlet 处理jsp文件  删除？
                            mime-mapping 相应的减少
                            welcome-file-list 欢迎页
            conf/server.xml AJP connerctor 的清理 <Connector port="8009" protocol="AJP/1.3" redirectPort="8443" />
                            Note:这个Connector 是可以被注释，他的作用类似于Nginx 是一个作多server负载均衡的统一端口 而一般我们都是用
                            		Nginx 而已。 这里可以猜测是tomcat为了宣传自己的负载方式而已！    
        调整配置参数：https://tomcat.apache.org/tomcat-8.0-doc/config/http.html
            <Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" />
            Connector 属性：maxThreads 线程池的最大线程数。 如果设置 默认为200  多余的请求会存储到队列中去
            protocol：org.apache.coyote.http11.Http11Protocol - blocking java  Connector
                      org.apache.coyote.http11.Http11NioProtocol - non blocking java nio Connector
                      org.apache.coyote.http11.Http11Nio2Protocol - non blocking java nio2 Connector
                      org.apache.coyote.http11.Http11AprProtocol - the APR/native Connector 本地io
                        默认  
                            7.0.x   http/1.1 Http11Protocol  blocking java  Connector-->BIO  
                            8.0.x   http/1.1 Http11NioProtocol -->NIO       
                            8.5.x   http/1.1 Http11NioProtocol -->NIO
            什么时候用APRProtocol 
                     bio<nio<nio2<apr           netty实际上就是根据nio2的一个异步线程的封装 
                     低并发实际上bio 比 nio效果还要好一些 
                     1 bio 默认200线程
                     2 nio 可能500并发的时候 线程只会创建50个 因为50个线程异步已经能够处理好500个并发了
                     3 大约是在并发300以内的时候  性能bio>nio
                     4 JVisualVM jmeter 测试并发情况
            具体优化见server.xml说明                    
            
    jvm调优：<内存大小的设置+GC算法的选择>
            java运行时，在jvm的一个分布：
                程序计数器： 记录程序运行的指令
                Java虚拟机栈： 线程私有
                本地方法栈：
                堆：线程共享
                非堆方法区(perm space/meta space):线程共享
            
            由上分布  我们可以推导 jvm优化可以从堆 非堆方法区进行优化，因为他们是线程共享的 其余部分都是随着线程生死的
            
            堆和非堆的详细划分：
                非堆：class 
                堆：
                    old：新生代
                    young：老年代
                        eden：
                        survivor：
                            s0:from区
                            s1:to区
            说明：堆中非新生代，老年代，老年代分eden区 survivor区 ，survivor分from区 to区 
                        一些朝生夕死的对象就存在young 一些存活比较久的放在old区 刚生成的对象放在eden区
                        survivor是监控整个eden 区对象的存活时间的。 from  to 区 是eden区的对象 到old区
                        的过渡存放区。  空间占比-->   eden:s0:s1 = 8:1:1 
                        tomcat的jvm优化我们可以从调整堆  非堆 ，也就是 老年年新生代区的空间占比以及
                        新生代空间的详细占比来达到优化的效果！           
                        GC算法的选择也很重要
                             
            jinfo tomcat运行线程id 能查看当前tomcat所使用的jvm 的一些数据信息 比如堆大小啊 非堆大小啊等
            jinfo -flag UseParallelGC PID 查看是否使用并行垃圾回收器  -表示没有使用 -XX：-UseParallelGC
            jinfo -flag UseG1GC PID 查看是否使G1垃圾回收器            +表示有使用   -XX：+UseG1GC
            
            -Xint 解释执行
            -Xcomp 第一次就编译
            -XX:InitialHeapSize=200M  -Xms 等价的
            -XX:MaxHeapSize=2000M  -Xmx 等价的
            -XX:UseG1GC 表示使用G1垃圾回收器
            
            GC算法：标记清除 复制算法  标记整理  
                young区使用复制算法比较好 
                old区标记清除或者标记整理比较好
            垃圾回收器：
                串行  seriaGC  这个垃圾回收器在跑的时候 应用程序线程得暂停  不太好   适用于小内存的
                并行  paralle,  sacvenge, paralle old 特点多条垃圾回收线程并行 但是程序线程仍然是等待的
                        吞吐量优先
                并发  CMS,G1 响应时间有限  吞吐量不有限
                
            选择垃圾回收器的评判标准：吞吐量 停顿时间
            
            
            总结：内存大小设置：dump内存日志 可以使用工具分析  MAT
                垃圾收集器选择：dump GC日志  可以使用工具分析 gceasy.io GCViewer
            
                    
                 