Tomcat支持三种接收请求的处理方式：BIO、NIO、APR 
 1. BIO由于每个请求都要创建一个线程来处理，线程开销比较大，不能再高并发的场景，性能也是最低的。
 2. NIO是一个基于缓冲区、并能提供非阻塞I/O操作的Java API，比传统的bio更好的并发性能。
 3. APR（Apache Portable Run-time libraries）简单理解，就是从操作系统级别解决异步IO问题，大幅度的提高服务器的处理和响应性能， 也是Tomcat运行高并发应用的首选模式。

tomcat优化思路：

配置文件优化：
        减少、增加配置：
            定位到比较重要的文件,conf/web.xml  conf/server.xml   项目中的web.xml(尽可能的清理不必要的配置！)
            conf/web.xml    defaultServlet  静态资源  删除？
                            jspServlet 处理jsp文件  删除？
                            mime-mapping 相应的减少
                            welcome-file-list 欢迎页
            conf/server.xml AJP connerctor 的清理 <Connector port="8009" protocol="AJP/1.3" redirectPort="8443" />
                            Note:这个Connector 是可以被注释，他的作用类似于Nginx 是一个作多server负载均衡的统一端口 而一般我们都是用
                            		Nginx 而已。 这里可以猜测是tomcat为了宣传自己的负载方式而已！    
        调整配置参数：https://tomcat.apache.org/tomcat-8.0-doc/config/http.html
            <Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" />
                    Connector 属性：maxThreads 线程池的最大线程数。 如果设置 默认为200  多余的请求会存储到队列中去
                                    acceptCount 所有可能的请求处理线程正在使用时传入连接请求的最大队列长度。队列满时收到的任何请求都将被拒绝。默认值是100。
                                    acceptorThreadCount 用于接受连接的线程数。在多CPU机器上增加这个值，虽然你永远不会真的需要更多2。另外，有很多非保持活动的连接，你可能也想增加这个值。默认值是 1。
                                    maxConnections 服务器接受并处理的最大连接数 对于NIO和NIO2，默认值是10000
            protocol：org.apache.coyote.http11.Http11Protocol - blocking java  Connector
                      org.apache.coyote.http11.Http11NioProtocol - non blocking java nio Connector
                      org.apache.coyote.http11.Http11Nio2Protocol - non blocking java nio2 Connector
                      org.apache.coyote.http11.Http11AprProtocol - the APR/native Connector 本地io
                        默认  
                            7.0.x   http/1.1 Http11Protocol  blocking java  Connector-->BIO  
                            8.0.x   http/1.1 Http11NioProtocol -->NIO       
                            8.5.x   http/1.1 Http11NioProtocol -->NIO
            什么时候用APRProtocol 
                     bio<nio<nio2<apr           netty实际上就是根据nio2的一个异步线程的封装 
                     低并发实际上bio 比 nio效果还要好一些 
                     1 bio 默认最大200线程  最小10线程
                     2 nio 可能500并发的时候 线程只会创建50个 因为50个线程异步已经能够处理好500个并发
                     3 大约是在并发300以内的时候  性能bio>nio
                     4 JVisualVM jmeter 测试并发情况
            具体优化见server.xml说明                    
                        
jvm调优：<内存大小的设置+GC算法的选择>
            java运行时，在jvm的一个分布：
                程序计数器： 记录程序运行的指令
                Java虚拟机栈： 线程私有
                本地方法栈：
                堆：线程共享
                非堆方法区(perm space/meta space):线程共享
            由上分布  我们可以推导 jvm优化可以从堆 非堆方法区进行优化，因为他们是线程共享的 其余部分都是随着线程生死的
            堆和非堆的详细划分：
                非堆：class 
                堆：
                    old：新生代
                    young：老年代
                        eden：
                        survivor：
                            s0:from区
                            s1:to区
            说明：堆中非新生代，老年代，老年代分eden区 survivor区 ，survivor分from区 to区 
                        一些朝生夕死的对象就存在young 一些存活比较久的放在old区 刚生成的对象放在eden区
                        survivor是监控整个eden 区对象的存活时间的。 from  to 区 是eden区的对象 到old区
                        的过渡存放区。  空间占比-->   eden:s0:s1 = 8:1:1 
                        tomcat的jvm优化我们可以从调整堆  非堆 ，也就是 老年年新生代区的空间占比以及
                        新生代空间的详细占比来达到优化的效果！           
                        GC算法的选择也很重要
                             
            jinfo tomcat运行线程id 能查看当前tomcat所使用的jvm 的一些数据信息 比如堆大小啊 非堆大小啊等
            jinfo -flag UseParallelGC PID 查看是否使用并行垃圾回收器  -表示没有使用 -XX：-UseParallelGC
            jinfo -flag UseG1GC PID 查看是否使G1垃圾回收器            +表示有使用   -XX：+UseG1GC
            
            -Xint 解释执行
            -Xcomp 第一次就编译
            -XX:InitialHeapSize=200M  -Xms 等价的
            -XX:MaxHeapSize=2000M  -Xmx 等价的
            -XX:UseG1GC 表示使用G1垃圾回收器
            
            GC算法：标记清除 复制算法  标记整理  
                young区使用复制算法比较好 
                old区标记清除或者标记整理比较好
            垃圾回收器：
                串行  seriaGC  这个垃圾回收器在跑的时候 应用程序线程得暂停  不太好   适用于小内存的
                并行  paralle,  sacvenge, paralle old 特点多条垃圾回收线程并行 但是程序线程仍然是等待的
                        吞吐量优先
                并发  CMS,G1 响应时间有限  吞吐量不有限
                
            选择垃圾回收器的评判标准：吞吐量 停顿时间
            
            
总结：内存大小设置：dump内存日志 可以使用工具分析  MAT
      垃圾收集器选择：dump GC日志  可以使用工具分析 gceasy.io GCViewer
            
      Linux :
      修改 /usr/program/tomcat7/bin/catalina.sh 文件，把下面信息添加到文件第一行。
      如果服务器只运行一个 Tomcat
        机子内存如果是 4G：
        CATALINA_OPTS="-Dfile.encoding=UTF-8 -server -Xms2048m -Xmx2048m -Xmn1024m -XX:PermSize=256m -XX:MaxPermSize=512m -XX:SurvivorRatio=10 -XX:MaxTenuringThreshold=15 -XX:NewRatio=2 -XX:+DisableExplicitGC"
        机子内存如果是 8G：
        CATALINA_OPTS="-Dfile.encoding=UTF-8 -server -Xms4096m -Xmx4096m -Xmn2048m -XX:PermSize=256m -XX:MaxPermSize=512m -XX:SurvivorRatio=10 -XX:MaxTenuringThreshold=15 -XX:NewRatio=2 -XX:+DisableExplicitGC"
        机子内存如果是 16G：
        CATALINA_OPTS="-Dfile.encoding=UTF-8 -server -Xms8192m -Xmx8192m -Xmn4096m -XX:PermSize=256m -XX:MaxPermSize=512m -XX:SurvivorRatio=10 -XX:MaxTenuringThreshold=15 -XX:NewRatio=2 -XX:+DisableExplicitGC"
        机子内存如果是 32G：
        CATALINA_OPTS="-Dfile.encoding=UTF-8 -server -Xms16384m -Xmx16384m -Xmn8192m -XX:PermSize=256m -XX:MaxPermSize=512m -XX:SurvivorRatio=10 -XX:MaxTenuringThreshold=15 -XX:NewRatio=2 -XX:+DisableExplicitGC"
        如果是 8G 开发机
        -Xms2048m -Xmx2048m -XX:NewSize=512m -XX:MaxNewSize=1024m -XX:PermSize=256m -XX:MaxPermSize=512m
        如果是 16G 开发机
        -Xms4096m -Xmx4096m -XX:NewSize=1024m -XX:MaxNewSize=2048m -XX:PermSize=256m -XX:MaxPermSize=512m
                    
       -Dfile.encoding：默认文件编码
       -server：表示这是应用于服务器的配置，JVM 内部会有特殊处理的
       -XX:UseG1GC 表示使用G1垃圾回收器 垃圾回收器的选择
       -Xmx1024m：设置JVM最大可用内存为1024MB
       -Xms1024m：设置JVM最小内存为1024m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。
       -Xmn1024m：设置JVM新生代大小（JDK1.4之后版本）。一般-Xmn的大小是-Xms的1/2左右，不要设置的过大或过小，过大导致老年代变小，频繁Full GC，过小导致minor GC频繁。如果不设置-Xmn，可以采用-XX:NewRatio=2来设置，也是一样的效果
       -XX:NewSize：设置新生代大小
       -XX:MaxNewSize：设置最大的新生代大小
       -XX:PermSize：设置永久代大小
       -XX:MaxPermSize：设置最大永久代大小
       -XX:NewRatio=4：设置年轻代（包括 Eden 和两个 Survivor 区）与终身代的比值（除去永久代）。设置为 4，则年轻代与终身代所占比值为 1：4，年轻代占整个堆栈的 1/5
       -XX:MaxTenuringThreshold=10：设置垃圾最大年龄，默认为：15。如果设置为 0 的话，则年轻代对象不经过 Survivor 区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，
                则年轻代对象会在 Survivor 区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。需要注意的是，设置了 -XX:MaxTenuringThreshold，并不代表着，
                对象一定在年轻代存活15次才被晋升进入老年代，它只是一个最大值，事实上，存在一个动态计算机制，计算每次晋入老年代的阈值，取阈值和MaxTenuringThreshold中较小的一个为准。
       -XX:+DisableExplicitGC：这个将会忽略手动调用 GC 的代码使得 System.gc() 的调用就会变成一个空调用，完全不会触发任何 GC   
          
       以下可选项：
       -XX:SurvivorRatio ：改变Eden对象空间和残存空间的尺寸比例，意思是Eden对象空
       -XX:NewRatio ：改变新旧空间的比例，意思是新空间的尺寸是旧空间的1/8（默认为8）
       
       Windows: 
       修改 /tomcat7/bin/catalina.bat 文件，找到这一行：echo Using CATALINA_BASE: "%CATALINA_BASE%"，然后在其上面添加如下内容，此方法只对解压版的 Tomcat 有效果，
       对于安装版本的需要点击安装后任务栏上的那个 Tomcat 图标，打开配置中有一个 Java Tab 的进行编辑。
     
        set JAVA_OPTS=%JAVA_OPTS% -Dfile.encoding="UTF-8" -Dsun.jnu.encoding="UTF8" -Ddefault.client.encoding="UTF-8" -Duser.language=Zh
        set JAVA_OPTS=%JAVA_OPTS% -server -Xms4096m -Xmx4096m -Xmn2048m -XX:PermSize=256m -XX:MaxPermSize=512m -XX:SurvivorRatio=10 -XX:MaxTenuringThreshold=15 -XX:NewRatio=2 -XX:+DisableExplicitGC