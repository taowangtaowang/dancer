**redis** 
        
    说明：单线程的 没有线程安全问题！   
          C语言写的 ,笔记为3.2版本的,redis约定次版本号（第一个小数点后的数字）为偶数版本是稳定版，如2.8、3.0， 奇数版本为非稳定版，默认端口6379
    应用场景： 缓存 任务队列 应用排行榜  网站访问统计  数据过期处理  分布式集群架构中的session分离
基础应用：
        
    安装启动：
    bin文件夹说明：
             Redis-server       Redis服务器
             Redis-cli Redis    命令行客户端
             Redis-benchmark    Redis性能测试工具
             Redis-check-aof    Aof文件修复工具
             Redis-check-dump   rdb文件检查工具
             Redis-sentinel     Sentinel服务器（2.8以后）
             redis-server ../redis.conf   Redis-server --port 6380  redis-cli SHUTDOW
    
    所有数据类型的api查询 ：http://redisdoc.com/hash/index.html
    数据类型： key-value: key 不能过长 不能超过1024字节 不然检索过慢    默认16个库（0-15） 5种数据结构  redis存储字符是2进制安全的（什么是二进制安全？ 字符后面加'\0' 表示结尾）
    
        string  能存储任何形式的字符串，包括二进制数据支持,字符串.整数.浮点,  value最大能容纳512M 
                内部数据结构：1  在Redis内部，String类型通过 int、SDS(simple dynamic string)作为结构存储，int用来存放整型数据，sds存放字节/字符串和浮点型数据
                              2  redis3.2分支引入了五种sdshdr类型，目的是为了满足不同长度字符串可以使用不同大小的Header，从而节省内
                              存，每次在创建一个sds时根据sds的实际长度判断应该选择什么类型的sdshdr，不同类型的sdshdr占用的内存空
                              间不同。这样细分一下可以省去很多不必要的内存开销。
                              基本上分为5种长度大小 2^5-1  2^8-1  2^16-1   2^32-1    2^64-1   如果是 2^5-1= 也会选择为2^8-1
                计数器： 整数INCR来实现
                使用场景：session共享  IP限制(incr)  短信验证(防止盗刷1分钟之类只能提交一次)  
                
        list    列表类型(list)可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素或者获得列表的某一个片段。 列表类型内部使用双向链表实现，
                所以向列表两端添加元素的时间复杂度为O(1), 获取越接近两端的元素速度就越快。这意味着即使是一个有几千万个元素的列表，获取头部或尾部的10条记录也是很快的
                内部数据结构：1  redis3.2之前，List类型的value对象内部以linkedlist或者ziplist来实现, 当list的元素个数和单个元素的长度比较小
                                 的时候，Redis会采用ziplist（压缩列表）来实现来减少内存占用。否则就会采用linkedlist（双向链表）结构
                              2   redis3.2之后，采用的一种叫quicklist的数据结构来存储list，列表的底层都由ziplist实现，
                                  这两种存储方式都有优缺点，双向链表在链表两端进行push和pop操作，在插入节点上复杂度比较低，但是内存开
                                  销比较大； ziplist存储在一段连续的内存上，所以存储效率很高，但是插入和删除都需要频繁申请和释放内存
                                  
                                  quicklist仍然是一个双向链表，只是列表的每个节点都是一个ziplist，其实就是linkedlist和ziplist的结合，quicklist
                                  中每个节点ziplist都能够存储多个数据元素，
                使用场景：
                          队列： 先进先出（消息队列：生产者lpush   消费者brpop）
                          栈：后进先出 lpush   lpop
                
        hash    可以看成是一个整体的对象 有属性，以及属性值。
                内部数据结构：1  hashtable
                              2  ziplist (数据量小的时候)
                使用场景：存储对象 对象的主键为key
        set     无序不重复特性,集合类型中，每个元素都是不同的，也就是不能有重复数据，同时集合类型中的数据是无序的。
                一个集合类型键可以存储至多2^32-1个 。集合类型set和列表list类型的最大的区别是有序性和唯一性,
                集合类型set的常用操作是向集合中加入或删除元素、判断某个元素是否存在。由于集合类型在redis内部是使用的值为空的散列表(hash table)，  值为null！
                所以这些操作的时间复杂度都是O(1)。
                内部数据结构：1 intset   2 hashtable   当set中只是包含整数类型的元素时，采用intset存储， 反之用hashtable存储 但是对于hashtable来说 值为null  只用key存   
                    
        sorted-set 有序集合  
                    在集合类型的基础上，有序集合类型为集合中的每个元素都关联了一个分数，redis正是通过分数来为集合中的成员进行从小到大的排序。
                这使得我们不仅可以完成插入、删除和判断元素是否存在等集合类型支持的操作，还能获得分数最高(或最低)的前N个元素、
                获得指定分数范围内的元素等与分数有关的操作。虽然集合中每个元素都是不同的，但是他们的分数却可以相同
                内部数据结构： 以ziplist或者skiplist+hashtable来实现的 跳跃有序集合   得了解数据的存储方式以及查询方式  ————变种2分法（类似于2分法）
                跳跃表的实现：
                    层的概念，每一个存储数据的node有一个层的概念  32 层 且有数据的那一层 都关联了 上下 同层不同node的值。  <这个不好描述 复习看pdf>
                