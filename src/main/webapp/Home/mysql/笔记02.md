存储引擎：

1 csv存储引擎

    数据存储是以csv的形式存储的
    数据存储使用，隔开的列定义必须为not null 不能设置自增列
    可以直接编辑csv ，编辑后flush table xxx 来使之生效
    应用场景：
        数据的快速导出导入  表格直接转换为csv

2 archive存储引擎

    只支持insert 和select 操作
    只允许自增id列建立索引 别的不允许了
    行级锁
    不支持事务
    数据占用磁盘非常少 是innodb占存储空间的的3%的样子（之前做的测试是innodb 100W条100M  archive存储引擎才3M多）
    select比innodb慢 除开主键索引哈
    应用场景：
        日志系统 不能修改 只能insert 和select
        大量的设备数据采集
3 memory存储引擎

    支持hash索引，btree索引  默认hash
    字段长度固定 char32
    不支持大数据存储类型 blog啊 text 啊
    表级锁
    应用场景：
        等值查找热度较高的数据
        查询结果中内存的计算，大多数都是采用这种存储引擎作为临时表来存储需要计算的数据 mysql8.0版本的临时表 已经废弃了这种存储临时表的方式

4 myisam存储引擎（mysql5.5之前默认存储引擎）

    select count（*） 不需要对全表进行数据扫描（它有一个专门存储表数据总数的地方）
    myd myi 索引和数据分开存储
    表级锁
    不支持事务

5 innodb 存储引擎 （mysql5.5以及之后的版本默认存储引擎）

    支持事务acid
    支持行级锁
    使用b+tree，利用主键索引聚集索引来组织数据
    支持外键关系保证数据的完整性


mysql 的体系结构

mysql查询优化详解

    客户端请求<------->查询缓存------->解析器------->预处理器
    返回结果             |                               |
      |                  |                               |
      |                  |                              \|/
      <----------------- |                           查询优化器
                         |                               |
                         |                               |
                         |                              \|/
                      结果--------------<查询执行引擎查询执行引擎>
                                            |
                                            |
                                           \|/
                                        存储引擎----->数据        

1   客户端，服务端通信，半双工——对讲机

    查询mysql 的通信状态  show full processlist/show processlist
    sleep 线程正在等待客户端发送数据
    query 线程正在执行查询
    locked 线程正在等候锁的释放
    sorting result线程正在对结果集排序
    sending data 向请求端返回数据
    
    kill id  杀掉线程
    
2   查询缓存

    缓存select 操作的结果集和sql语句。（sql语句 区分大小写，且如果在中间加空格 那么会识别为不一样的哦   trim()操作）
    查询缓存是否开启： 默认关闭
    show variables like 'query_cache%';
    结果：
    query_cache_type ：on 表示开启 默认off
    query_cache_size  ： 1048576 大小 1M
    query_cache_limit  ：1048576  1M
    每一个执行的结果能缓存的大小，超过这个大小将不会缓存（一般设置个16  32 M就行了）
    set global query_cache_type = 0;
    0表示关闭 
    1表示默认完全开启  加sql_no_cache可以不要缓存
    2表示按需开启  sql语句加关键字sql_cache才会开启
     
    show status like 'Qcache%';
    缓存的状态：
    Qcache_hits 缓存的命中次数
    Qcache_inserts 往缓存里面加了几条记录了
    select sql_no_cache * from users where id  =1;
    这样就不会往缓存中加
    select  * from users where id  =1;
    这样就会往缓存中加一条 加id=1这条数据
    再执行select  * from users where id  =1;
    就会命中缓存 hits次数就会加1 且 inserts不会增加
    top：
    1  《只要涉及到整张表的update 那么 整个表的所有缓存全部失效，所以他有些无用的！！！！！！！！！！》
    2  命中缓存的sql必须得相同  如果在结尾处加空格也是一样的。但是如果在sql中间加就会认为是一条新的sql  trim（）方法；
    3  select currdate(),* from user ;报错
        select *,curdate() from sys_user ;成功
    当遇到函数的情况是不会往cache里面加的
    4  加 sql_no_cahche 是不会忘缓存里面加的
    5 select 1； 不会涉及表 或者是查询系统表
       都不会忘 cache里面放
    6 单次查询超过limit设置的行数 也不会缓存数据
    
    适应场景：
        以读为主的业务：数据生成之后就不常改变的业务  比如日志
    
3   查询优化处理（sql报错一般都是在这个阶段报错的）
    
    解析sql---通过词法分析语法分析等将sql语句解析成解析树（对象）
    预处理阶段---根据mysql的规则进行进一步检查解析树的合法性，检查数据的表啊 列是否合法，权限验证啊 等等
    查询优化器----根据数据抽样执行，来找到最优的执行计划
    
    查询优化器是如何找到最优的执行计划的呢？
    > in的优化啊
            比如 where id=1 or id=2 or id=3 or id=4 与where id in (1,2,3,4)
            使用in会比较高效一点，因为
            or的处理方式： 每一条的id 值从左至右的与or条件匹配
            in的处理方式： 会先将（）里面的值进行排序，然后每一条数据 会先与括号里面的中间的值进行比对，
                           就是使用二分法进行比对，小的走左边，大的走右边。这样会高效一点！ 这个就是为什么在有or 的时候 会推荐使用in
    > 提前终止查询 limit 1;
            select * from user limit  1; 会提前终止对全表的扫描
    > 子查询优化   

4   执行计划——type
    
    访问类型，sql查询优化中一个很重要的指标，结果值从好到坏依次是system > const > eq_ref > ref > range > index > ALL  
      
    system：表只有一行记录（等于系统表），const类型的特例，基本不会出现，可以忽略不计 
    const：表示通过索引一次就找到了，const用于比较primary key 或者 unique索引 
    eq_ref：唯一索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键 或 唯一索引扫描 
    ref：非唯一性索引扫描，返回匹配某个单独值的所有行，本质是也是一种索引访问 
    range：只检索给定范围的行，使用一个索引来选择行 
    
    index：Full Index Scan，索引全表扫描，把索引从头到尾扫一遍 
    ALL：Full Table Scan，遍历全表以找到匹配的行



5   执行计划——extra

    额外信息
    1、Using filesort ： mysql对数据使用一个外部的文件内容进行了排序，而不是按照表内的索引进行排序读取 
    2、Using temporary使用临时表保存中间结果，也就是说mysql在对查询结果排序时使用了临时表，常见于order by 或 group by 
    3、Using index： 表示相应的select操作中使用了覆盖索引（Covering Index），避免了访问表的数据行，效率高 
    4、Using where ： 使用了where过滤条5、select tables optimized away： 基于索引优化MIN/MAX操作或者MyISAM存储引擎优化COUNT(*)操作，
        不必等到执行阶段在进行计算，查询执行 计划生成的阶段即可完成优化

《如何定位慢sql》

    1 业务驱动
    2 测试驱动
    3 慢查询日志
    
    慢查询日志配置：
    show variables like 'slow_query_log' 
    set global slow_query_log = on 
    set global slow_query_log_file = '/var/lib/mysql/gupaoedu-slow.log' 
    set global log_queries_not_using_indexes = on  <没有命中索引的是否要记录到慢查询中>
    set global long_query_time = 0.1 (秒)
    
    分析工具：
    mysqldumpslow -t 10 -s at /var/lib/mysql/gupaoedu-slow.log
    
    mysql 语句执行顺序？？？
    (1)from 
    (3) join 
    (2) on 
    (4) where 
    (5)group by(开始使用select中的别名，后面的语句中都可以使用)
    (6) avg,sum.... 
    (7)having 
    (8) select 
    (9) distinct 
    (10) order by 
    from-where-groupby-having-select-orderby-limit


