mysql 事务

    innodb 的特性：
    indexes 支持聚簇索引聚集索引
    lovking 行锁 (注意：只有 innodb  archive 引擎 是行级别的锁)
    mvcc 并发情况下的多版本控制
    transactions 事务
什么是事务？   
如何开启事务？

    begin/start transaction ;
    commit/rollback;
    set session autocommit = on/off 设定事务是否自动开启
事务特性：

    a 原子性 最小的工作单元 整个单元要么一起提交成功，要么全部失败回滚
    c 一致性 事务中数据操作及状态的改变是一致的，写入的规则必须符合规则，不会因为出现什么意外等原因导致状态不一致
    i 隔离性 一个事务所操作的事务，对其它事务的可见性设定（一般是设定为不可见）
    d 持久性 事务所做的修改是会永久保存的 不会因为系统的意外导致数据的丢失

事务带来了哪些问题？

    脏读————在update还没有commit 的时候去 select  然后再rollback，再select ，可能2次select出来的值是不一样的。就会出现脏读
    不可重复读 ————select之后update当条数据 然后再select，可能出现2次select不一样。出现不可重复读
    幻读————当select * from user where id >1 ;  (执行计划是type = range)时候，先select id>5;然后再insert id = 6 然后再select id>5 
                会出现2次select不一样。 比如之前没有 后面突然有了。这样会出现幻读。
    
                
针对上述这些问题引入了事务的隔离级别，那么又是如何解决上述3种问题的呢？

    事务的隔离级别：
                            脏读      不可重复读       幻读
    未提交读 RU             可能      可能            可能
    已提交读 RC             不可能    可能            可能
    可重复读 RR             不可能    不可能          对innodb是不可能的
    串行化serializable      不可能    不可能          不可能
    
    总结：innodb 默认隔离的级别RR 所以在市面上公司里基本上都是使用innodb
    
mysql 各个存储类型是如何解决的？innodb又是如何解决的？  锁！

    锁是用于管理不同事务对共享资源的并发访问
    表锁，行锁
        锁定粒度   表锁>行锁
        加锁效率   表锁>行锁
        冲突概率   表锁>行锁
        并发性能   表锁<行锁
    总结：innodb支持行锁，表锁（表锁实际上是把某表的所有行都锁住，算是一种另类的表锁）
    
mysql 的innodb 的锁类型：

    共享锁——S锁 读锁  都能读  但是不能写
        加锁：select * from user where id = 1 lock in share mode; 释放锁：rollback/commit;
    排它锁——X锁（排它锁的时候是可以select！！！） 排它锁不能与其它锁共存，如果一个事务获取了一行数据的排他锁，那么其它事务就
        不能获取了，只有获取了排它锁的事务才有权限对该条数据进行操作 （而其它事务读取数据可来自快照）
        加锁：delete、update、insert 默认加排它锁， select * from use where id =1 for update;  释放锁：rollback/commit;
    意向共享锁——IS锁 这个可以理解为共享锁的标志  例如火车上的厕所的 有人/无人 （厕所可供多人使用 只要里面有人 不管厕所满不满外面都是有人）
    意向排它锁——IX锁 这个可以理解为排它锁的标志  例如火车上的厕所的 有人/无人 （厕所可供多人使用 只要里面有人 不管厕所满不满外面都是有人）
    自增锁    
    
    行锁的算法：
    记录锁
    间隙锁
    临键锁
    
innodb的行锁：

    InnoDB的行锁是通过给索引上的索引项加锁来实现的。
    只有通过索引条件进行数据检索，InnoDB才使用行级锁，否则，InnoDB 将使用表锁（锁住索引的所有记录）
    只有通过索引条件进行数据检索，InnoDB才使用行级锁，否则，InnoDB 将使用表锁（锁住索引的所有记录）
    只有通过索引条件进行数据检索，InnoDB才使用行级锁，否则，InnoDB 将使用表锁（锁住索引的所有记录）
    
    表锁：lock tables xx read/write；
    
    例如 ；开启手动commit
    users表字段 id name age 
    id主键  name索引 
    1 update user where age  = '1';
       这个时候会锁住整个表
    2 update user where id  = '2';
       这个时候只会锁住id =1 的这条数据
    3 update user where name  = '3';
       这个时候只会锁住name =3 的这条数据
       这个时候其实mysql在辅助索引上加一把锁，
      且在对应的主键索引上也加一把锁
    用处举例：
    删除的时候，如果没有命中索引，那么会锁住整张表

自增锁？ 针对自增列自增长的一个特殊的表级别锁 show variables like 'innodb_autoinc_lock_mode';默认取值1，代表连续，事务未提交ID永久丢失

    永久丢失：
    自增id主键：
    比如 手动commit，
    insert 一条语句， 当我回滚之后，
    再次insert 再次回滚，
    然后insert 然后提交，那么自增的id值
    会不是连续的，会跳2次。 因为之前
    回滚的时候mysql是默认也给了id值
    也就是自增锁在起作用！
    相当于insert是强制串行！

临键锁？为什么innodb 选择临键锁next-key作为 行锁的默认算法？
    
间隙锁Gap锁？ 只在RR事务级别中存在

记录锁？

死锁？ 如何避免？

    
    
    
    
