mvcc-多版本并发控制
    
    就是并发访问数据库的时候，对整在进行事务内处理的数据做多版本管理，用以达到来避免在写操作时，阻塞了
    （串行化就阻塞了），从而引发的读操作的并发性能问题。
    
mvcc-逻辑流程插入

    字段：ID   NAME    AGE  (DB_TRX_ID  DB_ROLL_ID)（新增操作的事务id 为1）
          1     1       1       1         null
          2     2       2       1         null
      新增的理解：
    1 在我们的普通表中 有多余的2/3个字段，一个是数据行的版本号（新增事务id），一个是删除版本号（删除的事务id）。
    2 我们在一个事务中新增数据的时候，无论新增多少条，新增数据行的版本号都是一样的！
      删除版本号同理 就是说以一个事务开始结束为准！    
      
mvcc-逻辑流程删除

    字段：ID       NAME    AGE   (DB_TRX_ID  DB_ROLL_ID)（删除操作的事务id 为2）
          1         1       1       1         null
          2         2       2       1         2
      删除的理解：         
    1 删除是直接用新的版本号（事务id）插入删除版本号里面  
      
mvcc-逻辑流程修改

    字段：ID   NAME    AGE  (DB_TRX_ID  DB_ROLL_ID)（修改操作的事务id 为3，将id=1的age改成11）
        / 1     1      1       1          3
    copy  2     2      2       1          2
       \  1     1     11       3        null
    修改的理解：
    1 修改相当于删除加新增的操作
    2 先将命中的数据行进行copy，并且要将数据行更新哦。同时在老数据行的删除版本和新增数据行的版本号打上相同事务id
    
mvcc-逻辑流程查询    

    查询的理解：
      查询数据需要遵循2个规则：
        1 查找数据行版本需要早与当前事务版本id
        2 删除版本号要么为null 要么大于当前事务版本id
        
    查询这里的mvcc在下面的案例2是不适用的。
    mvcc 案例1： 先查询再修改再查询。
    mvcc 案例2： 查询再修改再查询。
    案例1,2 查询修改 都开启手动提交 仔细理解案例1是适合的：
        案例一的理解：
        1 先查询 再修改 再查询 ：
        3次操作都没有提交commit，这个时候查询按照上面的mvcc查询2个标准来比对，新增版本号要小于事务id  删除id为null或者大于事务id
        ，这个时候查询出来的结论是对的!!
        《修改的事务id为3 查询的事务id为2 》
        
        案例二的理解：
        查询 再修改 再查询 ：
        《修改的事务id为2  查询事务id为3 》
        次操作都没有提交commit，当第二次查询时候，即便是修改的操作提交commit或者不提交，还是得按照mvcc查询的2个标准来比对
        1 新增版本号比当前事务id小
        2 删除版本号为null或者比当前事务id大
        
        这个时候 如何 更新操作 rollback.那么就会出现幻读 把刚才 更新rollback之前的数据读取出来 
        
那么mysql是如何解决这个案例2存在的幻读问题呢？ ——dudolog /redolog

    undo log 的出现实现了2个作用：
    1 实现了事务的原子性 要么成功提交要么失败回滚
    2 在mysql innodb存储引擎中实现了多版本并发控制
    
    那么他是如何实现多版本控制的呢？？？
    我们的数据表teacher.ibd 会缓存一份。我们称他为缓存表块。 当
    事务update操作 会首先往undo buffer 中将当条数据写进去，做为备份。并且加意向排它锁，使得后续的对当表的读都读undo buffer
    如果commit 会将 会把当条数据的变更信息记录到redo buffer中去， 调用系统os将数据写入到redo log。
    rollback回滚的话 会把undo buffer 的数据恢复到 缓存数据块！！
    redo buffer   redo log 2 者实现了数据的持久化
    
    快照读：我们启动一个事务先去update，这个时候另外的事务去查询的时候 会发现 这个表或者这行数据已经被锁了（意向排他锁），
    然后就去读undo buffer  这个就叫快照读！！
    当前读：当我们的事务select 在意向排它锁OK 的时候，就是可以直接读取缓存表块， 这个时候就叫当前读！！
    
    
    
    redo buffer 
    解决的问题：事务持久性
    工作机制： 
      当我们事务对teacher表中的数据行做了update修改的时候，会把数据记录到 redo buffer ，然后定时或者实时将数据写入磁盘。
      写入磁盘redolog 就表示commit成功了。 redolog 会定时 将 redolog 日志与数据进行整合搞成新数据，重启mysql也会重做数据
      然后再重做teacher缓存块。清空redobuffer undobuffer。
    如果在redo buffer还未写入到redolog中去 断电 那么数据是会丢失的哦！！！。
    
    往redolog是顺序io 
    而 redolog整合ibd数据文件是随机io 
    说白了就是把耗时io转换成随机io。在空闲时执行耗时io
    
    -- 查询redolog记录位置
    show variables like 'innodb_log_group_home_dir' ; 
    -- 查询redolog日志文件组的个数
    show variables like 'innodb_log_files_in_group' ; 
    -- 查询redolog指在cache/buffer中的buffer池大小innodb_log_buffer_size 默认16M
    show variables like 'innodb_log_buffer_size' ; 
    -- 查询redolog 持久化Redo log的策略,Innodb_flush_log_at_trx_commit：
    show variables like 'Innodb_flush_log_at_trx_commit' ; 
    show variables like 'innodb_flush_log_at_timeout' ; 
    
    Redo buffer 持久化Redo log的策略， Innodb_flush_log_at_trx_commit： 
    取值 0 每秒提交  Redo buffer --> Redo log OS cache -->flush cache to disk[可能丢失一秒的事务数据] 
    取值 1 默认值， 每次事务提交执行Redo buffer --> Redo log OS cache -->flush cache to dis[最安全，性能最差的方式] 
    取值 2 每次事务提交执行Redo buffer --> Redo log OS cache 再每一秒执行 ->flush cache tdisk操作
    
    结论：删掉mysql 的 ib_logfile0/1  比删库安全多了
    
    
mysql 的配置优化：

    设置全局参数：数set global autocommit = ON/OFF;
    设置当前session参数：set session autocommit = ON/OFF;
    注意：
        全局参数的设定对于已经存在的会话无法生效 会话参数的设定随着会话的销毁而失效 
        全局类的统一配置建议配置在默认配置文件中，
        否则重启服务会导致配置失效
    
        mysql 的最大连接数的配置：
        最大连接数的配置：max_connections
        系统的句柄数配置：ulimit -a  /etc/security/limits.conf 
        msyql的句柄数配置：/usr/lib/systemd/system/mysqld.service
        这个最大连接数有限制的  
        max_connections<=msyql的句柄数配置<=系统的句柄数配置  
        
        内存参数配置——优化：DBA的事
        
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    