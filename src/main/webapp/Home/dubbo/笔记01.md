**dubbo**

    server：
    <!-- 提供方应用信息，用于计算依赖关系 --> 
    <dubbo:application name="practice-server" />
    <!-- 使用 multicast 广播注册中心暴露服务地址 --> 
    <dubbo:registry address="N/A" /> 或者类zk配置中心consul、etcd、nacos、sofa、zookeeper、redis、multicast 等等
    <!-- 用 dubbo 协议在 20880 端口暴露服务 --> 
    <dubbo:protocol name="dubbo" port="20880" />
    <!-- 声明需要暴露的服务接口 --> 
    <dubbo:service interface="com.gupaoedu.practice.LoginService"  ref="loginService" />
    <!-- 和本地 bean 一样实现服务 --> 
    <bean id="loginService" class="com.gupaoedu.practice.LoginServiceImpl" />
    
    client：
    <!-- 调用方应用信息，用于计算依赖关系 --> 
    <dubbo:application name="practice-client" />
    <!-- 使用 multicast 广播注册中心暴露服务地址 --> 
    <dubbo:registry address="N/A" />或者类zk配置中心consul、etcd、nacos、sofa、zookeeper、redis、multicast 等等
    <dubbo:reference id="loginService"  interface="com.gupaoedu.practice.LoginService" url="dubbo://192.168.9.128:20880/com.gupaoedu.practice.LoginService" />
    
    dubbo的另类Main.main(args)的启动：
        Main.main(args)——底层netty
        实际上底层给我们预置了容器：
        Spring Container 自动加载META-INF/spring 这个目录下的配置——默认
        logback Container 自动装配 log日志
        Log4j Container 自动配置log4j的配置
        
    dubbo +zk集群
        <dubbo:registry address="zookeeper://10.20.153.10:2181?backup=10.20.153.11:2181,10.20.153.12:2181"/>
        <dubbo:registry id="zookeeper"  address="zookeeper://192.168.13.102:2181" file="d:/dubboserver" /> 
        file 属性会把所有的请求的地址缓存到本地。而不用每次请求都要过一次zk
    
    dubbo还可多注册中心支持:
    <dubbo:registry address="zookeeper://192.168.13.102:2181" id="registryCenter1"/>
    <dubbo:registry address="zookeeper://192.168.13.102:2181" id="registryCenter2"/>
    <dubbo:service interface="com.gupaoedu.practice.LoginService" registry="registryCenter1,registryCenter2" ref="loginService" />
    dubbo的其他支持：
        1 当设置 <dubbo:registry check="false" /> 时，记录失败注册和订阅请求，后台定时重试
        2 可通过 <dubbo:registry username="admin" password="1234" /> 设置 zookeeper 登录信息
        3 可通过 <dubbo:registry group="dubbo" /> 设置 zookeeper 的根节点，默认使用 dubbo 作为 dubbo 服务注册的 namespace
    dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring初始化完成，以便上线时，能及早发现问题，默认 check="true"。可以通过 check="false" 关闭检查，
    
dubbo不仅是一个rpc框架：

    1   Dubbo 可以支持市面上主流的注册中心
        consul、etcd、nacos、sofa、zookeeper、redis、multicast 
    2   Dubbo 提供了 Container 的支持，默认提供了 3 种 container。我们可以自行扩展
        Spring Container 自动加载META-INF/spring 这个目录下的配置——默认
        logback Container 自动装配 log日志
        Log4j Container 自动配置log4j的配置
    3   Dubbo 对于 RPC 通信协议的支持，不仅仅是原生的 Dubbo 协议，它还围绕着 rmi、hessian、http、webservice、thrift、rest    
        例如集成wsdl协议：
                <!-- 用 dubbo 协议在 20880 端口暴露服务 --> 
                <dubbo:protocol name="dubbo" port="20880" /><
                dubbo:protocol name="webservice" port="8080" server="jetty"/><!-- 这里记得指定容器 --> 
                <!-- 声明需要暴露的服务接口 --> 
                <dubbo:service interface="com.gupaoedu.practice.LoginService" registry="registryCenter1"ref="loginService" protocol="dubbo,webservice"/>
                
    4   负载均衡
        4中实现：roundrobin/random/leastactive/ consistenthash
        <dubbo:service interface="..." loadbalance="roundrobin" />
        <dubbo:reference interface="..." loadbalance="roundrobin" />
        可以在服务端配置，也可以在客户端配置
        RandomLoadBalance《默认》   权重随机算法，根据权重值进行随机负载（weights=？），权重值的算法是比如0-9之前 [0,8），[8,10）数据random 到哪个区间 请求落到哪台机器。
        LeastActiveLoadBalance《推荐》  最少活跃调用算法，活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求这个是比较科学的负载均衡算法。
                    每个服务提供者对应一个活跃数 active。初始情况下，所有服务提供者活跃数均为 0。每收到一个请求，活跃数加 1，完成请求后则将活跃数减 1。在服务运行一段时间后，
                    性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求
        ConsistentHashLoadBalance   hash一致性算法，相同参数的请求总是发到同一提供者当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动
        RoundRobinLoadBalance   加权轮询算法 多个节点加权重的轮训 类似于randomloadBalance算法
        
    5   集群容错    
        @Service(loadbalance = "random", cluster = "failsafe")
        Failover Cluster    失败自动切换，当出现失败，重试其它服务器。(缺省)通常用于读操作，但重试会带来更长延迟。可通过 retries="2" 来设置重试次数(不含第一次)。
        Failfast Cluster    快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。
        Failsafe Cluster    失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。
        Failback Cluster    失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。
        Forking Cluster     并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks="2" 来设置最大并行数。
        Broadcast Cluster   广播调用所有提供者，逐个调用，任意一台报错则报错。(2.1.0 开始支持),通常用于通知所有提供者更新缓存或日志等本地资源信息。
        建议：
            在实际应用中 查询语句容错策略建议使用默认 Failover Cluster ，而增删改 建议使用Failfast Cluster 或者 使用 Failover Cluster（retries=”0”） 策略 
        防止出现数据 重复添加等等其它问题！建议在设计接口时候把查询接口方法单独做一个接口提供查询。
        
    6   服务降级
        Dubbo 中提供了一个 mock 的配置，可以通过mock 来实现当服务提供方出现网络异常或者挂掉以后，客户端不抛出异常，而是通过ock 数据返回自定义的数据
        实现方法：在客户端创建一个 mock 类并且实现对应的service接口，当出现服务降级时，会被调用对应的serviceMock方法
        
    7   动态配置——元数据中心等等 (2.7版本新功能)
        可以直接在dubbo-admin管理应用上直接 添加对应的dubbo.application.name dubbo.config-center.app-name 相关配置
        dubbo.registry.simplified=true 精简模式
     
    
                
            
            
                
        